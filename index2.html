<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Game (Beginner Version)</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .tile {
            transition: background 0.2s, color 0.2s;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center py-8">
    <!-- Title and Score -->
    <div class="mb-6 text-center">
        <h1 class="text-4xl font-bold text-gray-800">2048</h1>
        <div class="mt-2 text-lg text-gray-600">Score: <span id="score">0</span></div>
        <button id="newGameBtn" class="mt-4 px-4 py-2 bg-orange-500 text-white rounded shadow">New Game</button>
    </div>

    <!-- Game Board -->
    <div id="board" class="bg-gray-300 rounded-lg p-4 shadow-lg" style="width: 340px;">
        <!-- The grid will be generated by JavaScript -->
    </div>

    <!-- Message (Win/Lose) -->
    <div id="message" class="mt-6 text-xl font-bold text-center text-white bg-black bg-opacity-70 rounded p-4 hidden"></div>

    <!-- Instructions -->
    <div class="mt-8 bg-white rounded-lg p-6 shadow-md max-w-md">
        <h2 class="text-lg font-semibold mb-2">How to Play</h2>
        <ul class="text-gray-700 text-sm list-disc pl-5">
            <li>Use <b>arrow keys</b> or <b>swipe</b> to move tiles.</li>
            <li>When two tiles with the same number touch, they merge into one.</li>
            <li>Try to get the <b>2048</b> tile!</li>
        </ul>
    </div>

    <!-- Leaderboard Section -->
    <div class="mt-8 bg-white rounded-lg p-6 shadow-md max-w-md w-full">
        <h2 class="text-lg font-semibold mb-2">Leaderboard (Top 5)</h2>
        <ul id="leaderboard" class="text-gray-700 text-base list-decimal pl-5 mb-4"></ul>
        <form id="scoreForm" class="hidden flex flex-col gap-2">
            <input id="playerName" type="text" maxlength="20" placeholder="Your name" class="border rounded px-2 py-1" required />
            <button type="submit" class="bg-orange-500 text-white rounded px-3 py-1">Submit Score</button>
        </form>
    </div>

    <script>
    // --- Tile color mapping and Tailwind config ---
    const tileColors = {
        0: 'bg-gray-200',
        2: 'bg-tile-2',
        4: 'bg-tile-4',
        8: 'bg-tile-8',
        16: 'bg-tile-16',
        32: 'bg-tile-32',
        64: 'bg-tile-64',
        128: 'bg-tile-128',
        256: 'bg-tile-256',
        512: 'bg-tile-512',
        1024: 'bg-tile-1024',
        2048: 'bg-tile-2048',
    };
    tailwind.config = {
        theme: {
            extend: {
                colors: {
                    'tile-2': '#eee4da',
                    'tile-4': '#ede0c8',
                    'tile-8': '#f2b179',
                    'tile-16': '#f59563',
                    'tile-32': '#f67c5f',
                    'tile-64': '#f65e3b',
                    'tile-128': '#edcf72',
                    'tile-256': '#edcc61',
                    'tile-512': '#edc850',
                    'tile-1024': '#edc53f',
                    'tile-2048': '#edc22e',
                }
            }
        }
    };

    // Start a new game by resetting the board and state
    function newGame() {
        // Create a 4x4 grid filled with zeros
        board = Array(4).fill().map(() => Array(4).fill(0));
        score = 0;
        gameOver = false;
        gameWon = false;

        // Place two random tiles (2 or 4) on the board to start
        addRandomTile();
        addRandomTile();

        // Update the visual board and clear any win/lose messages
        updateBoard();
        showMessage('');
    }

    // Add a new tile (2 or 4) in a random empty cell
    function addRandomTile() {
        let empty = [];

        // Find all empty cells (value === 0)
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                if (board[r][c] === 0) empty.push([r, c]);
            }
        }

        // If there are no empty cells, do nothing
        if (empty.length === 0) return;

        // Pick a random empty cell and place a 2 or 4 there
        let [r, c] = empty[Math.floor(Math.random() * empty.length)];
        board[r][c] = Math.random() < 0.9 ? 2 : 4;
    }

    // Update the HTML display of the board and score
    function updateBoard() {
        const boardDiv = document.getElementById('board');
        boardDiv.innerHTML = ''; // Clear old tiles

        for (let r = 0; r < 4; r++) {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'flex mb-2 last:mb-0';

            for (let c = 0; c < 4; c++) {
                const val = board[r][c];

                // Create each tile with correct style and number
                const tile = document.createElement('div');
                tile.className = `tile w-16 h-16 flex items-center justify-center rounded-lg font-bold text-xl mr-2 last:mr-0 ${tileColors[val] || 'bg-gray-400'}`;
                tile.textContent = val === 0 ? '' : val;

                rowDiv.appendChild(tile);
            }

            boardDiv.appendChild(rowDiv);
        }

        // Update the score display
        document.getElementById('score').textContent = score;
    }

    // Move and merge tiles based on direction
    function move(direction) {
        // If game is already over or won, stop
        if (gameOver || gameWon) return;

        let moved = false;

        // Track which cells have already merged (so they can't merge again this move)
        let merged = Array(4).fill().map(() => Array(4).fill(false));

        // Helper function to slide a tile in a given direction
        function slide(row, col, dr, dc) {
            let r = row, c = col;
            while (true) {
                let nr = r + dr, nc = c + dc;

                // Stop if we're outside the grid
                if (nr < 0 || nr > 3 || nc < 0 || nc > 3) break;

                if (board[nr][nc] === 0) {
                    // Move tile into empty space
                    board[nr][nc] = board[r][c];
                    board[r][c] = 0;
                    r = nr; c = nc;
                    moved = true;
                } else if (board[nr][nc] === board[r][c] && !merged[nr][nc] && !merged[r][c]) {
                    // Merge two equal tiles
                    board[nr][nc] *= 2;
                    score += board[nr][nc];
                    board[r][c] = 0;
                    merged[nr][nc] = true;
                    moved = true;

                    // Check if we won
                    if (board[nr][nc] === 2048) {
                        gameWon = true;
                        showMessage('You Win!');
                    }
                    break;
                } else {
                    break;
                }
            }
        }

        // Directional movement logic — order matters!
        if (direction === 'left') {
            for (let r = 0; r < 4; r++) for (let c = 1; c < 4; c++) if (board[r][c]) slide(r, c, 0, -1);
        } else if (direction === 'right') {
            for (let r = 0; r < 4; r++) for (let c = 2; c >= 0; c--) if (board[r][c]) slide(r, c, 0, 1);
        } else if (direction === 'up') {
            for (let c = 0; c < 4; c++) for (let r = 1; r < 4; r++) if (board[r][c]) slide(r, c, -1, 0);
        } else if (direction === 'down') {
            for (let c = 0; c < 4; c++) for (let r = 2; r >= 0; r--) if (board[r][c]) slide(r, c, 1, 0);
        }

        // If something moved, add a new tile, update the board, and check for game over
        if (moved) {
            addRandomTile();
            updateBoard();
            if (isGameOver()) {
                gameOver = true;
                showMessage('Game Over!');
            }
        }
    }

    // Check if there are no moves left — if so, game is over
    function isGameOver() {
        for (let r = 0; r < 4; r++) for (let c = 0; c < 4; c++) {
            if (board[r][c] === 0) return false; // There's an empty cell
            if (c < 3 && board[r][c] === board[r][c+1]) return false; // Mergeable right
            if (r < 3 && board[r][c] === board[r+1][c]) return false; // Mergeable down
        }
        return true;
    }

    // Show a win/lose message or hide it if blank
    function showMessage(msg) {
        const msgDiv = document.getElementById('message');
        if (msg) {
            msgDiv.textContent = msg;
            msgDiv.classList.remove('hidden');
            showScoreForm();
        } else {
            msgDiv.classList.add('hidden');
            hideScoreForm();
        }
    }

    // Handle arrow key inputs
    document.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowLeft') move('left');
        else if (e.key === 'ArrowRight') move('right');
        else if (e.key === 'ArrowUp') move('up');
        else if (e.key === 'ArrowDown') move('down');
    });

    // Handle swipe gestures on touch devices
    let startX, startY;
    document.getElementById('board').addEventListener('touchstart', function(e) {
        if (e.touches.length === 1) {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        }
    });
    document.getElementById('board').addEventListener('touchend', function(e) {
        if (e.changedTouches.length === 1) {
            let dx = e.changedTouches[0].clientX - startX;
            let dy = e.changedTouches[0].clientY - startY;

            // Determine swipe direction
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 30) move('right');
                else if (dx < -30) move('left');
            } else {
                if (dy > 30) move('down');
                else if (dy < -30) move('up');
            }
        }
    });

    // Restart game when New Game button is clicked
    document.getElementById('newGameBtn').onclick = newGame;

    // Automatically start a new game on page load
    newGame();

    // --- Leaderboard Integration ---
    // Fetch and display top 5 scores
    function loadLeaderboard() {
        fetch('http://localhost:3000/highscores')
            .then(res => res.json())
            .then(data => {
                const list = document.getElementById('leaderboard');
                list.innerHTML = '';
                data.forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = `${entry.name}: ${entry.score}`;
                    list.appendChild(li);
                });
            });
    }

    // Show score submission form if game is over or won
    function showScoreForm() {
        const form = document.getElementById('scoreForm');
        form.classList.remove('hidden');
        document.getElementById('playerName').focus();
    }
    function hideScoreForm() {
        document.getElementById('scoreForm').classList.add('hidden');
    }

    // Handle score form submission
    document.getElementById('scoreForm').onsubmit = function(e) {
        e.preventDefault();
        const name = document.getElementById('playerName').value.trim();
        if (!name) return;
        fetch('http://localhost:3000/highscores', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, score })
        }).then(() => {
            hideScoreForm();
            loadLeaderboard();
        });
    };

    // Load leaderboard on page load
    loadLeaderboard();
    </script>
</body>
</html> 